%
%=======================================
%  template.tex
%=======================================
%
\documentclass[12pt,titlepage,fleqn]{article}
\usepackage{amsmath}
\usepackage{amssymb}
\usepackage{latexsym}
\usepackage[round]{natbib}
\usepackage{xspace}
%\usepackage{epsfig}
\usepackage{graphicx}
\usepackage{bm}
\usepackage[usenames]{color}
\usepackage{enumerate}

% do not use when showing Table of Contents
%\usepackage{fancybox} 
\usepackage{fancyhdr}
\pagestyle{fancy}
\fancyheadoffset[R]{12pt}
\lhead{}
\chead{}
\rhead{Q Liu}

% SPACING COMMANDS (Latex Companion, p. 52)
\usepackage{setspace}
\renewcommand{\baselinestretch}{1.0}
\textwidth 470pt
\textheight 630pt
\oddsidemargin 0pt
\evensidemargin 0pt

% see Latex Companion, p. 85
%\voffset     -50pt
\topmargin     0pt
\headsep      20pt
\headheight   15pt
\headheight    0pt
\footskip     30pt
\hoffset       0pt

% nicer fonts
\usepackage{times}

% self-defined commands
\include{newcommands}

% bibliography
\bibliographystyle{gji}

%======================================================
\begin{document}
%======================================================
\begin{spacing}{1.0} % empty lines are required!
\begin{center}

\Large {\vspace{0.1in} \bf \verb+CMT3D_FLEXWIN+ Manual}

\small
Qinya Liu \\
Department of Physics \\
%Faculty of Arts and Science \\
University of Toronto

\today

\end{center}

\end{spacing}

%======================================================
\verb=CMT3D_FLEXWIN= is re-written from my old \verb=CMT3D= program to
\begin{itemize}
\item adapt to the output windows file from Alessia's \verb=FLEXWIN= package, which runs through data and synthetics to pick time windows with decent match between data and synthetics.
\item eliminate bandpass filter as it should have been applied before entering \verb+FLEXWIN+.
\item deploy proper derivatives for location parameters, in particular epicenter, in either a local or global \textit{cartesian} coordinate system (instead of $lat$ and $lon$). \blue{Note a key modification from the old} \verb+INVERSION.PAR+\blue{: $dlat/lon$ in degrees now becomes $dX_E/X_N$ in km}.
\item incorporate centroid time shift and half duration as inversion parameters (npar=10 and 11).
\item reflect the gist of the program, which is to use Gaussian elimination to solve the inverse problem.
\end{itemize}
What still remains to be added is the possiblity of \verb+CMT3D+ inversion for multiple subevents, which may be useful if $N_{event}$ is relatively small, and may be handy for efficiency comparisons to \verb+CMT3D_CG+.


%===========================================================
\section{Setup}

\subsection{Setup derivative cmt solutions}
According to the theory in the Appendix, we need to compute the derivative synthetics 
\eq \papa{s}{m} \sim \frac{s(m+\Delta m)-s(m)}{\Delta m} \en
for all source parameters involved in the inversion. Depending on how many parameters are chosen (npar), we need to run at least $6-9$ simulations to gather all the derivatives. Each SEM simulation requires a corresponding \verb+CMTSOLUTION+, and the $\Delta m$ should be chosen carefully to avoid either numerical inaccuracy or instability. For global code (\verb+SPECFEM3D_GLOBE+), a choice may be
\eq
\Delta M = 1\times 10^{24}\text{ dyne.cm},\quad \Delta X = 2\text{ km},
\en
and for basin code (\verb+SPECFEM3D+), a choice may be
\eq
\Delta M = 1\times 10^{22}\text{ dyne.cm},\quad \Delta X = 0.5\text{ km},
\en
where $\Delta X$ refers to both perturbations in horizontal location (e.g, $X_\tht$ and $X_\phi$) as well as radius or depth (e.g, $X_r$).

Depending on what coordinate system you choose to calculate derivatives and run \verb+CMT3D+ inversions, different extensions need to be added to derivative \verb+CMTSOLUTION+s as well as the output synthetics:
\begin{itemize}
\item basin code, local UTM coordinates (utm $\in[1,60]$): \\
   \verb+ext=['Mrr','Mtt','Mpp','Mrt','Mrp','Mtp','dep','lon','lat']+ \\
I kept this option to retain continuity from the old version. Derivatives for $M$ are in RTP coordinate system, and location is in depth (that is opposite from radius), east and north (as in UTM coodinate). The \blue{key difference} is that derivatives for $X_E$ and $X_N$ are not simple perturbations on $lon$ and $lat$, but accurately calculated from UTM transformations.
\item global code, local RTP coordinates (utm $=0$):\\
   \verb+ext=['Mrr','Mtt','Mpp','Mrt','Mrp','Mtp','rrr','ttt','ppp']+\\
Here consistent coordinate system is used for all parameters (moment tensor and location). \blue{Note here $X_r$ is in the opposite sense from depth}, $X_\tht$ simple refers to $X_S$ and $X_\phi$ refers to $X_E$.
\item global code, global XYZ coordinates (utm $=-1$):\\
   \verb+ext=['Mxx','Myy','Mzz','Mxy','Mxz','Myz','xxx','yyy','zzz']+\\
This coordinate system may not be invoked for either local or global events. However, it may come in handy when multiple sub-event inversions are performed in the future.
\end{itemize}
For derivations of rotation matrices, please refer to the Appendix.

\begin{enumerate}
\item 
Python script and modules are provided in \verb+scripts+ directory to facilitate this process, and allow full compatibility with \verb+CMT3D+ code:
\begin{verbatim}
 gen_cmt_der('CMTSOLUTION',npar=9,dmoment=1.e24,
              ddepth=2,dlocation=2,utm=0)
\end{verbatim}
\item Also as indicated by the theory section, derivatives for centroid time and half duration simply depend on the synthetics, therefore no extra simulation is necessary.
\item After simulations for these derivative \verb+CMTSOLUTION+s finish, collect synthetic seismograms, convert them to sac files and add proper extension to the sac files according to the choice of coordinate system.  

\item Note synthetics for the original \verb+CMTSOLUTION+ do not need to be obtained through an extra simulation, a simple linear combination of moment tensor derivatives can be realized by:
\begin{verbatim}
 xadd_frechet_derivatives s syn_list cmt moment_scale(1e24)
\end{verbatim}

\end{enumerate}

\subsection{Pre-processing data and synthetics}

After gather raw data from IRIS or SCEDC, and collect synthetics as well derivative synthetics from SEM simulations you need to go through the pre-processing step to present properly cut and filtered data and synthetics to the \verb=FLEXWIN= package. I have come a long way in writing such scripts, and right now I am settled on a recent one in python:
\begin{verbatim}
 process_ds.py  \
  -d data,sac -s syn,  -p CMTSOLUTION,STATIONS\
  -t 6,30 -w -D [-r]
\end{verbatim}
%\verb=-d= and \verb=-s= give directory names and extension names of the raw data and synthetics. \verb=-0=,\verb=-1=\verb=-2=,\verb=-3= represents different pre-processing stages which you can choose to run separately. During \verb=-0=, information is gathered from \verb=CMTSOLUTION= and \verb=station_file= and written into sac headers. New directories \verb=data_PP= and \verb=syn_PP= are created to host these pre-processed data and syn files. During \verb=-1= stage, data and synthetics are padded before the beginning time to a value specified by \verb=-b=, and proper cutting between data and synthetics are performed to ensure futher operations. \verb=-2= stage mainly deals with band-passing data and synthetics between the frequence bands given by \verb=-t=, and moving the new processed files to directories \verb=data_T006_T030= and \verb=syn_T006_T030=. \verb=-3= stage writes out the input file \verb=flexwin_T006_T030.input= for \verb=FLEXWIN= package after all the above steps have been executed. The script structure and many implementation details are inspired by a similar script written by Carl Tape.
For detailed usage, simple type \verb+process_ds.py+. The outcomes of this script are
\begin{itemize}
\item filtered data and (derivative) synthetics in \verb+data_6_30+ and \verb+syn_6_30+. 
\item an input file to \verb+FLEXWIN+ named \verb+INPUT_flexwin_6_30+ is generated.
\end{itemize}

\subsection{Executing FLEXWIN}
After choosing the right parameters in \verb=PAR_FILE= and user functions for flexwin package (please refer to FLEXWIN manual for details), 
\begin{verbatim}
./flexwin < INPUT_flexwin_6_30 > OUTPUT_flexwin_6_30
\end{verbatim}
After running flexwin through data and synthetics filtered at various period bands,  all individual windows files in \verb+MEASURE_t1_t2+ directories can be cat into an input for \verb=cmt3d_flexwin= package.
\begin{verbatim}
write_flexwin_out.py MEASURE_6_30 MEASURE_20_50 INPUT_cmt3d_flexwin_noweight
\end{verbatim}
Now it is possible to pad time shift and weight information to the composite output windows file, either to facilitate a direct evaluation of misfit function, or to eliminate the weight calculations in \verb+CMT3D+ package, which can be rather cumbersome and inflexible.
\begin{verbatim}
write_flexwin_shift_weight.py -c 2/2/1 -d 1.15/0.55/0.78 -a 0.2 -r 2 -t \
      -D data -s MEASURE  INPUT_cmt3d_flexwin_noweight INPUT_cmt3d_flexwin_withweight
\end{verbatim}
Obviously you can not just blindly use this package without checking. Here are two auxilliary scripts:
\begin{verbatim}
plot_flexwin.py MEASURE 
plot_data_and_syn.pl -d data_dir,data_ext -s syn_dir,syn_ext -m cmt \
   -M OUTPUT_flexwin -A (Z/R/T) 0.05/0.05/0.08 
\end{verbatim}
The first script gives \verb+flexwin_seismo.pdf+ and the second one gives \verb+ds_all.pdf+.
%============================================
\section{CMT3D}
\subsection{Parameter file}
For structures of the main program and subroutine calls, refer to \verb=call-graph=. The name of the parameter file is hard-wired in the main program as \verb=INVERSION.PAR=.

\begin{verbatim}
CMTSOLUTION
CMTSOLUTION_NEW
6  0   0. 0.                   -- npar[, utm_zone, utm_x, utm_y]
1.0 1.0  1.0e22                -- dlocation,ddepth,dmoment
flexwin.out
.true. .false.                 -- weigh_data_files[, read_weight]
2 2 1  0  1.15 0.55 0.78       -- weights of data comp,az,dist
.true.                         -- station_correction
.true.  .true. 0.0             -- zero_trace,double_couple,damping
.false.                        -- write_new_syn
\end{verbatim}
The first line gives the old cmt solution file name. This is also the cmt solution you have used to generate derivative cmts and compute the synthetics from linear combinations. The second line gives name of the new cmt solution file written after the inversion is done.\\
File \verb=flexwin.out= holds the start and end time of the windows outputed from FLEXWIN package, in the following format:
\begin{verbatim}
nfiles
data-file-1
syn-file-1
 nwins-for-this-data-and-syn
 tstart(1) tend(1) [tshift(1) weight(1)]
 ...
 tstart(nwin) tend(nwin) [tshift(nwin) weight(nwin)]
data-file-2
syn-file-2
...
\end{verbatim}
Only windows from this output file will be used to perform time integration in assembling the inversion matrices. Note the values in [] are recent additions where we allow weights to be specified in the input file together with an indicative logical \verb+read_weight+. For now, `tshift' are still dummy variables not used for aligning data and synthetics (a separate corr subroutine calculates it in the code, but future merge may be possible).

All other parameters are pretty self-explanatory:
\begin{itemize}
 \item Number of parameters to be inverted can only be 6(moment-only), 7(moment+depth), 9(moment+locations). Values of integer \verb+utm+ indicate the coordinate system used for the derivatives and source inversion. Values of \verb+utm_center_x+ and \verb+utm_center_y+ are used only when \verb+utm+$\in [1,60]$.
 \item The derivative synthetics should have been calculated based on the \verb=ddelta=, \verb=ddepth=, \verb=dmoment= values. However, notice that strictly speaking, only the ones for moment are actual derivative synthetics; the ones for depth, longitude, and latitude (or R, S, E depending on coordinate system or utm) are actual synthetics, from which the code subtracts the old synthetics and divides it by ddepth or ddelta (refer to Appendix for more details). 
 \item Weighting subroutine \verb=compute_data_weights()=  needs to be tinkered if you choose to \verb=weigh_data_files=, and not importing weights directly from the input file by \verb=read_weight=. The idea is that you utilize the \verb=dist_km=, \verb=dist_deg=, \verb=azimuth=, and other file information from the sac headers to come up with a sensible weighting scheme for your particular scale/region.
 \item Station correction is used to align the data with the synthetics to accommondate 3D path effects that may bias your source inversion results.
 \item Different constraints on the moment-tensor are allowed, including zero-trace and double-couple. To improve the stability of the matrix inverse (when only very few windows are used), damping is also allowed before Gaussian elimination.
 \item Finally synthetics for the new cmt solution can be written, however, notice that these are obtained from `linearized' approximation, not from an actual SEM simulation.
 \end{itemize}

Some more words on weighting:
\begin{itemize}
\item If you want to invert either only surface waves or body waves, make sure you set the optimal parameters in flexwin.

\item How do the weights work:
\begin{verbatim}
        data_weights(nwint) =  cmp_weight(nwint) &
             * (dist/REF_DIST) ** dist_exp_weight(nwint) &
             * corr(nwint) ** corr_exp_weight(nwint) & 
             / ( naz(k) ** az_exp_weight)
\end{verbatim}
 where component weights are applied linearly, distance and azimuth weights are applied exponentially (such that $0$ means no weight and $1$ means linear weight). \verb=naz(k)= is the number of traces available in a particular azimuth (\verb=+1=). One can set \verb=az_exp_weight= to be 0 to mute out the azimuthal effect, the same for distance weights.

\end{itemize}
This package has been fully tested for $6,7,9,10$ parameter inversions based on synthetic data.

%======================================================

\appendix
\section{CMT3D Theory}
\subsection{Moment-tensor Inversions}
We seek to minimize the difference between data $\{d_i(t),i=1,\ldots,N\}$ and corresponding synthetics $\{s_i(\bbm,t),i=1,\ldots,N\}$  computed for a given model parameters $\bbm=\{m_j,j=1,\ldots,M\}$ after applying some bandpass filter:
\eq
\phi(\bbm)=\oneovertwo \sum_{rq}  \int\,W_{rq}(t)\left[ \bs^b(\bbm,\bx_r,t)-\bd^b_i(\bx_r,t)\right]^2\,dt
\en
where $W_{rq}(t)$ combines the taper function with weighting factor for the q'th window at r'th receiver. $\bs^b$ and $\bd^b$ denote filtered data and synthetics.

If we take the first and second order derivatives of this misfit function at some given reference model $\bbm^0$, we obtain
\eqa
\papa{\phi(\bbm^0)}{m_j} &=& \sum_{i=rq} \int\,W_{rq}(t)\left[ \bs^b(\bbm^0,\bx_r,t)-\bd^b(\bx_r,t)\right]\papa{s_i(\bbm^0,\bx_r,t)}{m_j}\,dt \\
\papapan{\phi(\bbm^0)}{m_j}{m_k} &\sim& \sum_{i=rq}  \int\,W_{rq}(t)\papa{\bs^b(\bbm^0,\bx_r,t)}{m_j}\papa{\bs^b(\bbm^0,\bx_r,t)}{m_k}\,dt
\label{eq:first-second-der}
\ena
where for the second-order derivatives, we have omitted the term related to second-order synthetics derivatives, i.e. approximate Hessian

By assuming that at the optimal model parameter $\bbm$, we have $\papa{\phi}{\bbm}=0$, which translates to the quasi-Newton's method:
\eq
\papa{\phi(\bbm^0)}{m_j}+\papapan{\phi(\bbm^0)}{m_j}{m_k}(m_k-m_k^0) = 0
\en
Therefore, we just need to compute the first and second-order derivatives according to equations \ref{eq:first-second-der}, which further points to the computation of derivative synthetic seismograms $\papa{s_i(\bbm^0)}{m_j}$.
%======================================================

\subsection{Derivative Synthetics}
We know in general, the synthetics for model $\bbm$ can be expanded with respect to a reference model $\bbm^0$:
\eq
s(\bbm,t)=s(\bbm^0,t) + \sum_{j=1}^M \papa{s_i(\bbm^0,t)}{m_j} (m_j-m_j^0)
\en
If source parameters only include moment-tensor elements, then the linear dependences can be written as:
\eq
s(\bbm,t,t) = \sum_{j=1}^{M}\papa{s_i(\bbm^0,t)}{m_j} m_j
\en
Therefore derivatives for moment-tensor elements can be computed by
\eq
\papa{s_i(\bbm^0,t)}{M_j} = s(M_j^0,t)/M_j^0
\en
where $s(M_j^0,t)$ is the synthetics calculated by setting all the moment tensor elements other than the $j$th component to $0$.

For other source parameters, including event location and depth, a finite-difference formula has to be used:
\eq
\papa{s_i(\bbm^0,t)}{m_j} = \frac{s(m_j^0+\De m_j^0,t)-s(m_j^0,t)}{\De m_j}
\en
where $s(m_j^0+\De m_j^0,t)$ refers to synthetics computed from only perturbing the $j$'th component of the source parameters. $\Delta m_j$ needs to be selected with care to avoid numerical noise. Typically $2-5$ km for global earthquakes and $1$ km for local earthquakes.

Derivatives for time shift and half duration can be derived from the original synthetics itself. Given a Gaussian source time function
\eq
g(t) = \frac{1}{\sqrt{\pi}t_h}e^{-\left(\frac{t-t_s}{t_h}\right)^2} \quad
\text{or}\quad g(\om) = e^{-\frac{\om^2 t_h^2}{4}} e^{-i\om t_s}
\en
under the Fourier transformation pairs:
\eq
F(\om) = \int_{-\infty}^{\infty} f(t) e^{-i\om t}dt, \quad f(t+a) \Leftrightarrow F(\om) e^{i\om a},
\quad \dot{f}(t) \Leftrightarrow (i\om) F(\om)
\en
Given Green's functions for a point source with delta moment function, we can express the synthetics for an earthquake as
\eq
\bs(\bx_r,\om) = \frac{M}{i\om} : \nab G(\bx_r,\bx_s,\om) g(\om)
\en
i.e., synthetics for error function as moment function.  Therefore
\eq
\papa{\bs(\bx_r,\om)}{t_{s,h}} = \frac{M}{i\om} : \nab G(\bx_r,\bx_s,\om)\papa{g(\om)}{t_{s,h}}.
\en
Since 
\eqa
\papa{g(\om)}{t_s} &=& -(i\om) g(\om)  \nn \\
\papa{g(\om)}{t_h} &=& -\frac{1}{2} t_h \om^2 g(\om) = -\oneovertwo t_h (i\om) \papa{g(\om)}{t_s} 
\ena
we have
\eqa
\papa{s(\bbm_0,t)}{t_s} &=& -\dot{\bs}(\bbm_0,t) \nn \\
\papa{s(\bbm_0,t)}{t_h} &=& -\frac{1}{2}t_h \pa_{t} [\papa{s(\bbm_0,t)}{t_s}]
\ena
%======================================================
\subsection{Rotation between Global and Local coordinates}
A series rotation is needed to tranform local $(r,\tht,\phi)$ coordinates
(which is also what CMT moment tensor uses) into the global coordinates $(X,Y,Z)$, where $X$ is pointing to $\Deg{0}$ longitude, and vice versa.

For a given point with $(\tht=90-Lat,\phi=Long)$ on a \textbf{unit} sphere, the coordinates in the cartesian global coordinate system is given by
\eq
X=\sin\tht\cos\phi,\quad Y=\sin\tht\sin\phi,\quad Z=\cos\tht
\en
Conversely, given the global coordates $(X,Y,Z)$, 
\eq
\tht = acos(Z/r),\quad  \phi=atan2(Y/\sin\tht, X/\sin\tht)
\en
Note here if $\tht=0$ (North pole), then $\phi$ is undetermined, and can be basically any number.

For rotation matrices, as an example, in 2-D, for the same point, the coordinates under new coordinate system is related to the old coordinates by
\eq
\begin{bmatrix} X_{new} \\ Y_{new}\end{bmatrix}
= \begin{bmatrix} \cos\tht & \sin\tht \\ -\sin\tht & \cos\tht \end{bmatrix}
\begin{bmatrix} X_{old} \\ Y_{old}\end{bmatrix}
\en
\begin{figure}[h]
\putfigure{5in}{rot.png}
\caption{Rotation matrices}
\end{figure}
After the first two simple rotations ($Z (\phi)$ and $Y(\tht)$) demonstrated by Figure 1, we have the relation between $(X,Y,Z)$ and $(\tht,\phi,r)$ systems:
\eq
\begin{bmatrix} x_{\tht} \\ x_{\phi} \\ x_{r} \end{bmatrix}
= \begin{bmatrix} \cos\tht & 0 & - \sin\tht \\ 
0 & 1 & 0 \\ \sin\tht & 0 & \cos\tht \end{bmatrix}
\begin{bmatrix} \cos\phi & \sin\phi & 0 \\ 
-\sin\phi & \cos\phi & 0 \\ 0 & 0 & 1 \end{bmatrix}
\begin{bmatrix} X \\ Y \\ Z\end{bmatrix}
\en
This is not the end of story, as the usual order of local coordinate system is $(r,\tht,\phi)$ instead of $(\tht,\phi,r)$. Therefore two extra rotations ($Y(-\Deg{90})$ and $X (-\Deg{90})$) are needed, which give an extra (left-applied) rotation matrix
\eq
\begin{bmatrix} 1 & 0  &  0 \\ 
0 & \cos(-\Deg{90}) & \sin(-\Deg{90}) \\ 
0 & -\sin(-\Deg{90}) & \cos(-\Deg{90}) \end{bmatrix}
\begin{bmatrix} \cos(-\Deg{90}) & 0 & -\sin(-\Deg{90}) \\ 
0 & 1 & 0 \\
\sin(-\Deg{90}) & 0  & \cos(-\Deg{90}) \end{bmatrix}
\en
Multiply these two matrices together, we obtain the final rotation matrix from $(X,Y,Z)$ to $(r,\tht,\phi)$:
\eq
R^T=
\begin{bmatrix} 
\sin\tht\cos\phi & \sin\tht\sin\phi  &  \cos\tht \\ 
\cos\tht\cos\phi & \cos\tht\sin\phi & -\sin\tht \\ 
-\sin\phi & \cos\phi & 0 \end{bmatrix}
\en
which can be verified by
\eq
\begin{bmatrix} 1 \\ 0 \\ 0\end{bmatrix}=
R^T
\begin{bmatrix} \sin\tht\cos\phi \\ \sin\tht\sin\phi \\ \cos\tht\end{bmatrix}
\en
The rotation matrix from local $(r,\tht,\phi)$ to global $(X,Y,Z)$ is simply:
\eq
R=\begin{bmatrix} 
\sin\tht\cos\phi & \cos\tht\cos\phi  &  -\sin\phi \\ 
\sin\tht\sin\phi & \cos\tht\sin\phi & \cos\phi\\ 
\cos\tht & -\sin\tht & 0 \end{bmatrix}
\en
%======================================================

%============================================

\section{Testing (further update awaits)}

Two types of datasets are provided to accurately test this inversion package, one with station correction, and one without. Synthetics and derivative synthetics for corresponding \verb=CMTSOLUTION= are always in \verb=syn_T006_T030=. No pre-processing are needed for these dataset as they have gone through all the procedures. Although to achieve inversion result that is accurate to several digits after the decimal point, several tweaks with the usual pre-processing procedures have to be done.

\begin{itemize}
\item  \blue{(obsolete, needs fix)} we should not use \verb=-h= in the synthetics processing to ensure that the synthetics data and the derivative synthetics go through the exact same set of processing procedures. we also need to take out the \verb=rtrend= and \verb=rmean= line in the filtering steps of \verb=process_syn_new.pl= and \verb=process_cal_data.pl= (\red{?}). Since the data and synthetics presented in \verb=test_dataset= have gone through the script:
\begin{verbatim}
  process_data_and_syn.pl  -d data,sac -s syn,  \  
         -0 -m CMTSOLUTION -a station_file   \
         -1 -b -26 -2 -t 6/30
\end{verbatim}
which generated \verb=process_ds.csh= script for all the commands, we can just tweak individual lines in \verb=process_ds.csh= to achieve our test dataset. Also
note that the \verb=-i none= option for data processing and \verb=-h= option for synthetics processing have to be taken out from the script to make sure that synthetics and data are processed in exactly the same way.

\item The synthetic data for the 7 paramter case are generated by the following command:
\begin{verbatim} 
  xadd_frechet_full s syn_file_list old_cmt true_cmt \
                    doment depth dx[dy]
\end{verbatim}
which is a fancier version of the original
\begin{verbatim}
  xadd_frechet_derivatives s syn_file_list \
                           cmt_file moment_scale
\end{verbatim}
Of course we can't really use the true synthetics for the true cmt solution in a 7-par case, since we know that the synthetics is a non-linear function of depth, and the inversion won't accurately recover depth. Linearized `pseudo-synthetics' will ensure accurate results, which is the purpose of testing.

\item It is impossible to design test dataset for 7 parameter inversion with time shift, since time shifts interfer with the effect of waveform change caused by depth variation, therefore, may not give exact solution, and sometimes may even produce the incorrect solution. This is part of the reason why I also wrote the grid search package \verb=GRID3D_FLEXWIN=.
\end{itemize}
%=======================================================

\section{Auxilliary Scripts and Programs}
A list of the scripts that are used before and after the package:
\begin{itemize}
\item \verb=process_data_and_syn.pl=, which includes \\ 
 \verb=process_data_new.pl=(global/regional) or \verb=process_cal_data.pl= (socal), \\
 \verb=process_syn_new.pl= (global/regional) or \verb=process_trinet_syn_new.pl=(socal), \\
 \verb=pad_zeros.pl= (include \verb=pad_zero_to_syn=), \verb=rotate.pl=, \verb=saclst=. Of course \verb=sac= has to be present in the system.
\item \verb=prepare_meas_all.pl=
\item \verb=xadd_frechet_derivatives= and \verb=xadd_frechet_full=
\end{itemize}


\end{document}
